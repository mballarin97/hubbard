# Scalable digital quantum simulation of lattice fermion theories with local encoding

Repository for the simulation of the Defermionized Hubbard model reported in the paper
[Scalable digital quantum simulation of lattice fermion theories with local encoding](https://arxiv.org/abs/2310.15091).
In this repository, we report all the code for reproducing the result of the digital computations.


## Table of content

- [The model](#model)
- [Checks of correctness of the digital mapping](#checks)
- [Initial state](#initial_state)
- [Visualize the state](#visualize_state)
- [Run the program](#run)
- [Measurable observables](#observables)
- [Plotting the results](#plot)
- [Requirements](#requirements)
- [Ground state search](#gss)

<div id='model'/>

### The model

After the transformation described above we end up with a lattice that has 2 qubits on
each site and 2 qubits on each link. The symmetries that we need to protect, using the
stabilisers formalism, are:

- Parity of the matter, in the vertexes of the lattice. The qubits on the
  vertexes can be either `00` or `11`. We will call qubits on the vertexes
  **matter** qubits.
- Parity of the links. The qubits on the links can be either `00` or `11`.
  From now on, we will call qubits on the links **rishons** qubits.
- Anticommutations rules of fermions, imposed by a symmetry on the plaquettes.

<div id='checks'/>

### Checks of correctness of the digital mapping

In the folder `checks/` we report a series of checks on the correctness of the mapping.
The python files should be run from this folder, i.e. **not from the `checks/` folder**
in order to work.
The checks we perform are the followings:

1. **Mapping**. We look at the operators of the Hamiltonian, making sure everything is
   correct following the theory of the paper. We look specifically at the quantum circuit
   for the evolution.
2. **Commutator**. We analyse the commutation relations between the stabilizers enforcing
   the correct symmetry sector and the Hamiltonian. Everything should commute, and it does.
3. **Exact diagonalization**. We perform the exact diagonalization on small scales, i.e.
   a `2x2` system with both our mapping and the Jordan Wigner mapping, checking that the
   whole spectrum is the same.
4. **Evolution**. Run the evolution of the system through statevector for small scales.


<div id='initial_state'/>

### Initial state

We use the `generate_initial_quantities.py` script to generate all the quantities related
to the initial states and the evolution. Specifically, we generate the following items:

1. The initial state before the adiabatic procedure. It is a "chessboard-like" state
   that is reported in the paper and symmetric under a global $X$ reflection.
   The state is prepared by first initializing a single configuration of the checkboard
   (as in the example for visualizing the state below) and by enforcing the correct
   symmetry sectors by measuring the stabilizers.
2. Generation of the adiabatic circuit. It is a single, parameterized timestep of the
   circuit used to perform the adiabatic evolution. The generation of the circuit is
   time consuminf, and thus we just do it once here, and later on fix the parameters
   during the evolution
3. Generation of the evolution circuit. It is a single timestep of the trotterized
   evolution induced by the defermionized Hubbard Hamiltonian.
4. It also saves a bunch of parameters, containing the parameters of the circuits
   and additional informations such as the number of 2-qubits gates and the construction
   times.

Once the initial quantities are generated, you can continue to adiabatically prepare the
ground state of the model to further run the simulations. To do so, use the
`adiabatic_mps.py` file. Notice that it will fail if you did not generate the initial
quantities before.

<div id='visualize_state'/>

### Visualize the state

The python script let the user have a nice representation of the state. We show below an
example of the generated output. The rishons are on the edges, while up and down species
are inside the sites (square boxes).

```bash
┌───┐     ┌───┐
│0,0├──1──┤1,1│
└─┬─┘     └─┬─┘
  │         │
  1         1
  │         │
┌─┴─┐     ┌─┴─┐
│1,1├──1──┤0,0│
└───┘     └───┘
```

<div id='run'/>

## Run the program

The main executable of the repository is the file `main.py`. It enables the simulation of the Hubbard model using quantum circuits.
Many parameters are read from the file generated by `generate_initial_quantities.py`, i.e.:

- `shape`, the shape of the 2d lattice;
- `hopping_constant`, the strength of the the hopping;
- `num_timesteps_before_measurement`, the frequency of the measurements (measure avery `n` timesteps);
- `dt`, the time discretization;

It is possible instead to pass the following arguments when running the program:

- `--num_timesteps`, number of timesteps in the evolution. Default to `5000`.
- `--max_bond_dim`, maximum bond dimension of the evolution. Default to `1024`.
- `--initial_state_idx`, index of the folder where the initial state is saved. Default to `0`.
- `--excitation`, type of excitation to inject at the beginning of the evolution. Available `"spin"` and `"charge"`. Default to `None`.
- `--device`, device for the computation. Available `"cpu"` and `"gpu"`. Default to `"cpu"`
- `compute_correlator`, if True, compute correlators when measuring the observables. Be careful, they are computationally demanding. Default to `False`.

The results of the simulation are automatically stored in a folder called `data/idx`, where `idx` is an integer number uniquely characterizing the simulation. Inside the directory `data/idx/` the program will generate, during the runtime, six different files. The first one is a json file called `params.json`, where the input parameters of the simulation are saved. The others files contains the observables, described in the next section.

<div id='observables'/>

### Measurable observables

We measure the observables at each timestep. So, in the files,
each row will be a different observation.

- $\langle n_{\uparrow,\downarrow}\rangle$, the expectation value of the up and down spins on the sites. They are usually combined to get the charge and spin densities $\rho_{c,s}=\langle n_{\uparrow}\rangle \pm \langle n_{\downarrow}\rangle$. The results are recorded in the file `u_and_d.txt`. The first four columns represent the up species, while the last four the down species. The order is the same you obtain by calling the `HubbardRegister.keys()` method.
- $\langle n_{\uparrow}n_{\downarrow}\rangle$, the correlation between up and down spins on the sites. The results are recorded in the file `ud.txt`.
- $\langle K\rangle$, the expectation value of the kinetic term, which is equivalent to the hopping part of the Hamiltonian. The results are recorded in the file `kinetic.txt`.
- Checks on the symmetry of the plaquettes. If a `1` is present, then the symmetry is not respected and the evolution is worthless. There is a column for each plaquette. The results are recorded in the file `symmetry_check.txt`.
- $S_V$, the Von Neumann entanglement entropy by cutting in half the system. The results are recorded in the file `entanglement.txt`. The cut is done horizontally. For the implementation procedure, the cut is exactly half of the system only if the system has shape $(x, 2)$. We represent below the example of a cut in a $(3,2)$ lattice.

```bash
  O─r─O─r─O
  |   |   |
  | ┌───┐ |
  r │ r │ r
 ───┘ | └───
  |   |   |
  O─r─O─r─O
```

- `singvals.txt`, contains the norm truncated at each timestep. The product of these norms can be used as a lower bound for the
  fidelity of the algorithm
- `time.txt`, contains the elapsed time;
- `mps_state.txt`, contains the final state after the evolution, which can be used as initial state of a further evolution

<div id='plot'/>

### Plotting the results

We also provide a script to plot (and optionally save) the results of a simulation in a standard way.
The script is `plots/plot.py` and takes the following parameters:

- `plot_index`, a non-optional parameter that identifies the simulation you want to inspect.
- `--save`, if provided save the results in the `.pdf` format.
- `--path`, If provided, save in this PATH. Otherwise, save in `data/idx/`.
- `--no_plot`, If provided, do not call `plt.show()`. Useful for producing plots on clusters.

The plotting procedures are available for the kinetic, charge/spin densities and the entanglement.
Please feel free to implement plotting of the other quantities in `hubbard/plotter.py`, following
the examples already written, and then add the new lines in `plot.py`.

> :warning: If the plaquette symmetry is not satisfied at *any* time-step the plotter script will raise a `RuntimeError`.

Furthermore, the following files present in the same directory can be used:

- `plot_lattice.py`, plots the lattice highlighting the matter on the sites and the rishons on the links, with
  the 1d mapping drawn by a green curve;
- `plot_snapshots.py`, reproduces the figure of the paper.

<div id='requirements'/>

### Requirements

The requirements are reported in the `requirements.txt` file. To run the programs in the library, please
do as follows:

```
python3 -m venv hubbard_env
source hubbard_env/bin/activate

pip install qmatchatea==0.5.2
pip install qiskit_aqua
pip install tqdm
```

Optionally, if you want to reproduce the plots you can download and install [`qplotting`](https://baltig.infn.it/qpd/qplotting).
If you want to run the simulation on GPUs, install the optional dependency [`cupy`](https://docs.cupy.dev/en/stable/install.html).

#### Tweaks

The version of qiskit-aqua used for the library is not working by default.
When installed with pip, you need to modify the file
`/PATH/site-packages/qiskit/providers/__init__.py` and add the line
`from qiskit.providers.backend import Backend as BaseBackend`.

<div id='gss'/>

### Ground state search

It is possible also to perform the ground state searches simulations detailed in the first half of the paper.
To do so, you will need the additional dependency [`ed_lgt`](https://github.com/gcataldi96/ed-lgt).
Afterwards, just refer to the file `ttn_ground_state_search.py` to see how the operators are prepared
and how to setup the simulation.
